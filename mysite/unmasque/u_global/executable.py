"""
following function is refactored version generated by chatGPT
Test it though-roughly
"""


def get_result_as_tuple_1(res, result):
    for row in res:
        # Check if the whole row is None (SPJA Case)
        if all(val is None for val in row):
            continue

        # Convert all values in the row to strings and create a tuple
        row_as_tuple = tuple(str(val) for val in row)
        result.append(row_as_tuple)
    return result


"""
following function is the code from original unmasque after modularization.
"""


def get_result_as_tuple_0(res, result):
    for row in res:
        # CHECK IF THE WHOLE ROW IN NONE (SPJA Case)
        nullrow = True
        for val in row:
            if val is not None:
                nullrow = False
                break
        if nullrow:
            continue
        temp = []
        for val in row:
            temp.append(str(val))
        result.append(tuple(temp))
    return result


class Executable:
    _instance = None
    method_call_count = 0
    connectionHelper = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super(Executable, cls).__new__(cls)
        return cls._instance

    def __init__(self, connectionHelper):
        self.connectionHelper = connectionHelper

    def getExecOutput(self, query):
        print("inside :-- executable.getExecOutput")
        result = []
        try:
            res, description = self.connectionHelper.execute_sql_fetchall(query)
            self.method_call_count += 1
            colnames = [desc[0] for desc in description]
            result.append(tuple(colnames))
            if res is not None:
                result = get_result_as_tuple_1(res, result)

        except Exception as error:
            print('Executable could not be run. Error: ' + str(error))
            raise error
        return result


def getExecOutput(connHelper, query):
    exec = Executable(connHelper)
    return exec.getExecOutput(query), exec.method_call_count
